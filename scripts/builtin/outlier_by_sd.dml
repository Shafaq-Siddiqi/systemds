#-------------------------------------------------------------
#
# Copyright 2020 Graz University of Technology
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#-------------------------------------------------------------


# Builtin function for detecting and repairing outliers using standard deviation 
#
# INPUT PARAMETERS:
# ---------------------------------------------------------------------------------------------
# NAME            TYPE    DEFAULT     MEANING
# ---------------------------------------------------------------------------------------------
# X               Double    ---        Matrix X  
# k               Integer   ---        threshold values 1, 2, 3 for 68%, 95%, 99.7% respectively (3-sigma rule)
# isIterative     Boolean   TRUE       iterative repair or single repair 
# repairMethod    Integer     1        values 0 = delete outlier, 1 = replace by mean, 2 = replace by median
# ---------------------------------------------------------------------------------------------
 

#Output(s)
# ---------------------------------------------------------------------------------------------
# NAME                  TYPE    DEFAULT     MEANING
# ---------------------------------------------------------------------------------------------
# processed_X           Double   ---     Matrix X with no outliers




m_outlier_by_sd = function(Matrix[Double] X, Integer k = 2,  Boolean isIterative = TRUE, Integer repairMethod = 2, Boolean verbose = TRUE)
  return(Matrix[Double] processed_X) 
{

  if( k < 1 | k > 3)
    stop("invalid argument, k should be in range 1-3 found "+k)
  
  iterate = TRUE
  while(isIterative | iterate)
  {
    iterate = FALSE
    colSD = colSds(X)
    colMean = (colMeans(X))
  
    upperBound = colMean + k * colSD
    lowerBound = colMean - k * colSD
    
    outlierFilter = outer(X, lowerBound, ">") &  outer(X, upperBound, "<")
    if(verbose)
      print(sum(outlierFilter == 0))
    
    if(sum(outlierFilter == 0) > 0)
      X = fix_outliers(X, outlierFilter, repairMethod)
    else
      isIterative = FALSE
  }
  processed_X = X
  
  if(verbose)
    print(toString(processed_X))
}
  
fix_outliers = function(Matrix[Double] X, Matrix[Double] outlierFilter, Integer repairMethod = 2)
    return(Matrix[Double] fixed_X)
{

  rows = nrow(X)
  cols = ncol(X)
  if(repairMethod == 0)
  {
    sel = (1-(rowSums(outlierFilter == 0))>0)
    X = removeEmpty(target = X, margin = "rows", select = sel)
  }
  else if(repairMethod == 1)
  {
    Mask = 1 - outlierFilter
    Mask = Mask * (colMeans(X))
    X = outlierFilter * X
    X = X + Mask
  }
  else if(repairMethod == 2)
  {
    colSort = matrix(0, rows, cols)
    parfor(i in 1:cols)
      colSort[, i] = order(target=X[, i], by=1, decreasing=FALSE, index.return=FALSE)

    if(rows%%2 == 0)
      colMedian =  (colSort[rows/2, ] + colSort[(rows/2)+1, ])/2
    else
      colMedian =  (colSort[floor(rows/2), ])
      
    Mask = 1 - outlierFilter
    Mask = Mask * colMedian
    X = outlierFilter * X
    X = X + Mask
  }
  else
    stop("Invalid argument: repair required 0-2 found: "+repairMethod)
    
  fixed_X = X
}

