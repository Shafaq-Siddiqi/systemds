#-------------------------------------------------------------
#
# Copyright 2020 Graz University of Technology
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# Implements builtin for finding functional dependencies
# 
# INPUT PARAMETERS:
# ---------------------------------------------------------------------------------------------
# NAME            TYPE    DEFAULT     MEANING
# ---------------------------------------------------------------------------------------------
# X               Double  ---         matrix X of feature vectors
# Y               Double  ---         matrix Y of class labels
# intercept       Boolean False       No Intercept ( If set to TRUE then a constant bias column is added to X)
# num_classes     integer 10          Number of classes
# epsilon         Double  0.001       Procedure terminates early if the reduction in objective function 
#                                     value is less than epsilon (tolerance) times the initial objective function value.
# lambda          Double  1.0         Regularization parameter (lambda) for L2 regularization
# maxiterations   Int     100         Maximum number of conjugate gradient iterations
# ---------------------------------------------------------------------------------------------
 
#Output(s)
# ---------------------------------------------------------------------------------------------
# NAME            TYPE    DEFAULT     MEANING
# ---------------------------------------------------------------------------------------------
# FD              Double   ---        matrix of functional dependencies 

m_functional_dependency = function(Matrix[Double] R)
  return(Matrix[Double] FD)
{
 
  FD = matrix(0,ncol(R), ncol(R))
  FDCols = matrix(0,ncol(R), ncol(R))
  FDRows = matrix(0,ncol(R), ncol(R))
  cm = colMaxs(R)
  onesCol = matrix(1, ncol(R), 1)
  onesRow = matrix(1, 1, ncol(R))
  sequence = (nrow(R)*(nrow(R)+1))/2
  cm = order(target=t(cm), decreasing=TRUE, index.return=TRUE)
  parfor(i in 1 : ncol(R), check =0){
    index_i = as.scalar(cm[i,1])
    colDist = colDistinct(R[,index_i])
    columnSum = sum(R[,index_i])  
    if(colDist == 1.0) 
      FDCols[, index_i] = onesCol
    else if(columnSum == sequence)
      FDRows[index_i, ] = onesRow
    else
    {
      parfor(j in seq(i+1,ncol(R), 1), check =0){
        index_j = as.scalar(cm[j,1])
        [A_determines_B, del] = compute_dependency(R[, index_i], R[, index_j]);
        if(A_determines_B & del > 0.8){
          FD[index_i, index_j] = 1
        }
      }
    }
  }
  FD = (FD + FDCols + FDRows) != 0 
}

compute_dependency = function(Matrix[Double] X, Matrix[Double] Y)
  return(Boolean A_determines_B, Double delta)
{
  ctab = table(X, Y)
  rowMax = rowMaxs(ctab)
  rowMax = removeEmpty(target = rowMax, margin = "rows")
  rowSum = rowSums(ctab)
  rowSumTable = rowSums(ctab != 0)
  A_determines_B = (sum(rowSumTable == 1) == colDistinct(X));
  delta = sum(rowMax) / sum(rowSum ) 
}

colDistinct = function(Matrix[Double] X)
return(double distinctItems)
{
distinctItems = sum(table(X, 1) != 0)
}
